%\addcontentsline{etoc}{chapter}{\textit{Surname1 A1.\,B1., Surname2 A2.\,B2.} Title}

\begin{abstract}
Любой алгоритм, имеющий зависимость по времени между исходным текстом и ключом, содержит уязвимость. Связав время работы программы со значением ключа, криптоаналитик получит инструмент для атаки. В результате будет обнаружен ключ либо создан алгоритм, позволяющий дешифровать любое зашифрованное сообщение. Атаки по времени представляют собой значительную угрозу безопасности криптографических систем. Понимание принципов, лежащих в основе атак по времени, и реализация соответствующих мер противодействия --- важные шаги в защите конфиденциальной информации от злоумышленников.

\kwr атаки по времени, RSA, постоянное время исполнения, метод ослепления, криптоанализ

\blfootnote{\hspace{-7pt}\textcopyright \, Боборухин Д.\,Ю., 2024\\ \indent\textcopyright \, Федеральное государственное автономное образовательное учреждение высшего образования\\
\indent\hspace{15pt}<<Московский физико-технический институт
(национальный исследовательский университет)>>, 2024}

\end{abstract}

%\arthead{D.\,G. Boborukhin}
%{$^{1}$Place of work 1\par
% $^{2}$Place of work 2\par}
%{Title}

%\begin{abstract}
%Abstract in English
	
%\kwe keywords in English.
%\end{abstract}
%\bigskip


%Примерная структура статьи.

\section{Введение}
П. Кочер \cite{s1} первым заговорил об атаках по времени в 1996 году на конференциях "RSA Data Security" и "CRYPTO". Атака по времени --- это атака по побочным каналам, в которой атакующий пытается скомпрометировать криптосистему с помощью анализа времени, затрачиваемого на исполнение криптографических алгоритмов. Атаки через побочные каналы используют информацию о времени, энергопотреблении, электромагнитных излучениях или даже звуке для восстановления секретной информации о криптосистеме. \par
Каждая операция в криптографической системе исполняется какое-то число процессорных тактов и занимает время на исполнение, которое может отличаться в зависимости от входных данных или значения секретного параметра(ключа). Прежде всего, это связано с внутренними особенностями системы. Атаки по времени могут быть особенно разрушительными, поскольку для них не требуется физический доступ к целевой системе, их можно проводить удалённо по сети\cite{s3}.\par
Это является действительно важной проблемой, так как атаке по времени исполнения подвержены реализации известных алгоритмов шифрования, например RSA\cite{s2, s11, s14}, AES\cite{s12, s13}, DES, RC5, IDEA и другие.\par
Чтобы предотвратить атаки на время, разработчики должны применять методы безопасной разработки. Один из подходов заключается в обеспечении реализации криптографических систем в режиме постоянного времени исполнения\cite{s7}. Он подразумевает исключение зависимости времени от входных данных. Это устраняет уязвимости для атак по времени, которыми могут воспользоваться злоумышленники. Кроме того, введение случайных задержек или методов ослепления может помочь скрыть зависимость времени исполнения от входных данных.

\section{Причины появления уязвимости}
Зависимости времени работы алгоритма, или числа занимаемых процессорных тактов от входных данных может зависеть от нескольких факторов.\cite{s4}
\begin{enumerate}
\item[•] Прежде всего, это арифметические операции: некоторые арифметические операции могут занимать разное время в зависимости от операндов. Например, операции умножения или деления могут иметь разное время выполнения в зависимости от умножаемых или делимых значений.
\item[•] Условные ветвления\cite{s5}: если алгоритм содержит условные операторы, время выполнения может меняться в зависимости от исполняемого участка. Кроме того, предсказатель ветвлений часто создаёт потенциальную угрозу(Spectre угроза). \cite{s14} За счёт анализа спекулятивного исполнения и анализа по времени криптоаналитик получает возможность извлечь секретную информацию из системы.
\item[•] Оптимизация алгоритмов: некоторые криптографические оптимизации, ускоряющие выполнение операций для определенных входных значений могут хорошо работать лишь для некоторых параметров, что порождает расхождение во времени исполнения алгоритма.
\item[•] Шаблоны доступа к памяти: время доступа к памяти может меняться в зависимости от расположения данных. Если алгоритм при определённых входных параметрах обращается в основную память, а при других в кэш, это породит разницу во времени работы. Криптоаналитик может использовать эту вариацию для получения информации о шаблонах доступа к памяти, что, в свою очередь, может раскрыть секретную информацию.
\end{enumerate}

\section{Атака по времени на алгоритм RSA}
RSA - это криптосистема с открытым ключом, которая использует открытую экспоненту e для шифрования и закрытую экспоненту d для дешифрования. Она использует модуль $N$, который представляет собой произведение двух больших простых чисел $p$ и $q$, то есть $N = p*q$. Экспоненты $e$ и $d$ должны быть выбраны таким образом, чтобы удовлетворять условию $e*d = 1 mod (p - 1)(q - 1)$. Таким образом, ключевая пара RSA состоит из открытого ключа $(N, e)$ и закрытого ключа $d$.\par
Сила RSA заключается в том, что факторизация больших чисел является сложной задачей. Самые известные методы факторизации до сих пор работают очень медленно. Мы можем предположить, что RSA надежно защищена от факторизационной атаки для ключа подходящей длины. \par
\subsection{Алгоритм работы RSA}
Чтобы зашифровать сообщение $M$, вычисляется $C = M^e mod N$, где $C$ - зашифрованное сообщение, или шифротекст. Чтобы расшифровать шифротекст $C$, вычисляется $M = C^d mod N$, что дает исходное сообщение $M$. Расшифровка таким образом возможна благодаря результату из теории чисел, известному как теорема Эйлера. \par
Таким образом, расшифровка шифротекста представляет собой модульное экспонирование $M = C^d mod N$, где $N$ - модуль RSA, $C$ - шифротекст, а $d$ - закрытый ключ. Цель атакующего - найти $d$. Для атаки по времени атакующий должен заставить целевую систему вычислить $C^d mod N$ для нескольких тщательно выбранных значений $C$. Точно измерив необходимое время и проанализировав колебания времени, криптоаналитик может восстановить биты закрытого ключа. Атака по времени является проблемой обнаружения сигнала. Сигнал состоит из вариаций синхронизации, вызванных целевым битом экспоненты, а шум - из неточностей в измерениях синхронизации и случайных флуктуаций синхронизации, особенно в сети. В итоге, количество необходимых выборок синхронизации пропорционально количеству бит в экспоненте $d$, а также опрделяется свойствами сигнала и шума. Поскольку число бит в секретной экспоненте $d$ ограничено, атака практична с вычислительной точки зрения.

\begin{paracol}{2}
\begin{figure}[h] \centering
\begin{lstlisting}
    x = C
    for j = 1 to n
        x = mod(x^2, N)
        if d_j == 1 then
    	    x = mod(x*C, N) 
        end if
    next j
    return x	
\end{lstlisting}
\caption{Алгоритм быстрого возведения в степень\cite{s20}}
\end{figure}
\switchcolumn
%\noindent
\begin{flushleft}
Модульное экспонирование в RSA состоит из возведения большого числа в большую экспоненту, что является трудоемкой операцией. Простым и эффективным алгоритмом вычисления $C^d mod N$ является алгоритм быстрого возведения в степень. Его алгоритм приведен на Рис. 1 , где $d = d_0d_1..d_n$ в двоичном исчислении, причем $d_0 = 1$.
\end{flushleft}
\end{paracol}

В стандартных реализациях RSA для выполнения операций умножения и возведения в квадрат используется алгоритм Монтгомери. При использовании алгоритма Монтгомери умножение занимает постоянное время, не зависящее от размера множителей. Однако если промежуточный результат умножения превышает модуль N, выполняется дополнительное вычитание \cite{s2}. Именно этот дополнительный шаг вызывает разницу во времени для разных входов и раскрывает информацию о секретном ключе.\par
Другим типичным способом оптимизации реализации RSA является использование китайской теоремы об остатке(КТоО). При использовании КТоО функция $M = C^d mod N$ вычисляется сначала путем вычисления $M_1 = C^{d_1} mod N$ и $M_2 = C^{d_2} mod N$, где $d_1$ и $d_2$ предварительно вычисляются из $d$. Затем $M_1$ и $M_2$ объединяются для получения $M$. RSA с КТоО делает оригинальную атаку Кочера неработоспособной. Тем не менее, атака по времени может раскрыть множители N, а затем и сам секретный ключ \cite{s3}.
%\newpage
\subsection{Пример атаки на RSA}
Данная атака использует уязвимость, порождённую наличием условных переходов в алгоритме. То есть, при определённых входных данных, выполняются разные участки кода.\par
Пусть $C$ - сообщение для расшифровки, $d$ - закрытый ключ для восстановления, обозначаемый $d_0d_1..d_n$, где $d_0 = 1$. 

\newpage
\begin{paracol}{2}
\begin{figure}[h] \centering
\begin{lstlisting}
    if x >= N
       x = x % N
    end if
    return x	
\end{lstlisting}
\caption{Алгоритм взятия модуля\cite{s20}}
\end{figure}
\switchcolumn
%\noindent 
\begin{flushleft}
Предположим, что для вычисления модульного экспонтирования используется алгоритм быстрого возведения в степень (Рис. 1), а операция $mod(x, N)$ реализована, как показано на Рис. 2.
\end{flushleft} 
\end{paracol}
Рассмотрим алгоритм на Рис. 1. Если если $d_j = 1$, то выполняются две операции, $x = mod(x^2, N)$ и $x = mod(x*C, N)$, вместро одной в противном случае. Другими словами, при $d_j = 1$ время вычислений должно быть больше. Также обратим внимание на Рис. 2, что модульное сокращение выполняется только в том случае, если промежуточный результат умножения больше модуля N. Данная атака использует эти два факта. Таким образом, осуществляется анализ двух наборов сообщений, один из которых требует сокращения для вычисления $mod(x*C, N)$ , а другой --- нет. \par
Предположим, что мы можем заставить систему расшифровать сообщения по нашему выбору. Начнем атаку на $d_1$ с выбора двух сообщений $Y$ и $Z$, где $Y^3 < N$ и $Z^2 < N < Z^3$. Если $d_1$ действительно равно 1, то будет выполнена операция $x = mod(x * x^2, N)$ и время для расшифровки сообщения $Z$ будет больше, поскольку модульное сокращение не выполняется для сообщения $Y$. С другой стороны, если реальное значение $d_1$ равно 0, операция $x = mod(x * x^2, N)$ не будет выполняться, и вычисления для $Y$ и $Z$ должны занимать примерно одинаковое время. Таким образом мы можем восстановить бит $d_1$, и продолжить атаку для следующих бит.\\
Так как в этом случае разница во времени очень мала, используют набор сообщений $Y_i$ и $Z_i$ для $i = 0, 1, .., m-1$, удовлетворяющих начальным условиям. Пусть $y_i$ - время, необходимое для вычисления $Y_i^d mod N$, $z_i$ - время, необходимое для вычисления $Z_i^d mod N$. Вычисление среднего времени $y$ и $z$ по всем $i$ позволяет сгладить шумы и заметить разницу даже на небольших отклонениях.

\subsection{Реализации атаки на практике}
Ж. Дем и Ф. Кёун провели аналогичную атаку на раннюю версию смарт-карты CASCADE \cite{s2}. Они сообщили о взломе 512-битного ключа за несколько минут с помощью 350 000 измерений времени. 128-битный ключ можно было взломать со скоростью 4 бит/с, используя 10 000 измерений. \par
Д. Брумли и Д. Боне разработали атаку по времени на OpenSSL, криптографическую библиотеку с открытым исходным кодом, используемую в веб-серверах и других SSL-приложениях, и успешно извлекли закрытый ключ d \cite{s3}. До того как эта атака была обнародована, считалось, что атаки по времени не сработают против серверов общего назначения, поскольку колебания времени будут маскировать время расшифровки криптографического алгоритма. Тем не менее атака сработала в локальной сети между машинами, разделенными несколькими маршрутизаторами. Для удалённого извлечения 1024-битного ключа с сервера OpenSSL 0.9.7 потребовалось около миллиона запросов, примерно за два часа \cite{s3}.\par 
Таким образом, в сетях с малым разбросом задержек, таких как локальные или корпоративные сети, атака по времени вполне осуществима. В случае удаленной атаки, криптоаналитик должен учитывать и другие переменные, помимо задержки в сети, например нагрузку на сервер. То есть, в периоды низкой активности сервер может быть более уязвим.

\section{Методы защиты от атак по времени}
Чтобы избежать вышеперечисленные уязвимости для атак по времени существует несколько методов защиты, наиболее распространёнными их них являются програмирование с постоянным временем исполнения и ослепление. Эти техники могут быть реализованны как на аппаратном уровне, так и на уровне програмного стека.

\subsection{Программирование с постоянным временем исполнения}
При программировании с постоянным временем исполнения, производительность программы становится независимой от входных параметров\cite{s7}.\par
Программирование с постоянным временем исполнения подразумевает использование принципов, исключающих перечисленные выше причины появления уязвимости. Существует множество реализаций обхода потенциально опасных конструкций, мы перечислим основные из них, относящиеся к програмным решениям.\par
Чтобы арифметические операции выполнялись за постоянное время, независимо от операндов, можно использовать вычисления с фиксированной точкой. Для отказа от условных ветвлений часто применимы выражения с битовыми сдвигами, позволяющие получить тот же результат, но избежать зависимости от выбранной ветки. Единообразность шаблонов доступа к памяти может быть получена путём обращения ко всем элементам структуры данных по фиксированной схеме, независимо от фактических обрабатываемых данных. \par
Чтобы проиллюстрировать эти принципы, рассмотрим пример функции сравнения строк на языке C.\par

\begin{paracol}{2}
\noindent \center Потенциальная уязвимость
\begin{lstlisting}
int strcmp(char *s1, char *s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(char *)s1 - *(char *)s2;
}
 
 	
\end{lstlisting}
\begin{flushleft}
Данная реализация выходит из цикла, как только обнаруживает несоответствие, что приводит к изменению времени исполнения в зависимости от входных данных. Злоумышленник может использовать эти колебания времени для получения информации о сравниваемых строках.
\end{flushleft}
\switchcolumn % переключение на правый столбец
\noindent \center Код с постоянным временем исполнения
\begin{lstlisting}
int ct_strcmp(char *s1, char *s2) {
    unsigned char result = 0;
    while (*s1 && *s2) {
        result |= *s1 ^ *s2;
        s1++;
        s2++;
    }
    return result | (*s1 ^ *s2);
}
\end{lstlisting}
\begin{flushleft}
В данной реализации цикл выполняется на протяжении всей длины строк, а результат вычисляется с помощью побитовых операций, которые не вносят временных изменений в зависимости от входных значений.
\end{flushleft}
\end{paracol}
В примере алгоритма RSA можно избавиться от уязвимости, всегда выполняя дополнительное сокращение в алгоритме Монтгомери\cite{s2}. Однако необходимо следить за тем, чтобы дополнительное сокращение не было оптимизировано компилятором.

\subsection{Метод ослепления}
Данный метод подразумевает введение случайности в алгоритм вычисления, чтобы устранить зависимость времени исполнения от входных данных. Часто это реализуется путём дополнительных вычислений со случайной величиной.\par
Для случая RSA также реализован метод ослепления, это приводит к накладным расходам от $2\%$ до $10\%$. После работ Боне и Брумли\cite{s3}, OpenSSL 0.9.7 включает в своей реализации ослепление по умолчанию.

\section{Проблемы и ограничения методов защиты}
Программирование с постоянным временем исполнения и метод ослепления являются мощными техниками для защиты от атак по времени, однако они не лишены своих проблем и ограничений\cite{s6}.
\begin{enumerate}
\item[•] нагрузка на производительность: программирование с постоянным временем исполнения и использование методов ослепления может привести к накладным расходам на производительность, поскольку часто требует дополнительных операций. Это может быть компромиссом между безопасностью и производительностью, и он может не подходить для всех систем.
\item[•] сложность: написание алгоритмов с постоянным временем исполнения может быть более сложным и подверженным ошибкам, чем написание наивной реализации. Разработчики должны знать о потенциальных источниках временных отклонений и тщательно проектировать свой код, чтобы избежать их.
\item[•] верификация: проверка того, что код действительно работает в режиме постоянного времени, может оказаться непростой задачей. Требуется тщательный анализ и тестирование, чтобы убедиться в отсутствии скрытых вариаций синхронизации. Автоматизированные инструменты и формальные методы верификации в общем случае не являются безотказными.
\item[•] оптимизации компилятора: современные компиляторы могут вносить изменения во временные параметры за счет оптимизаций, которые упорядочивают или устраняют код. Для того чтобы скомпилированный код оставался безопасным, требуется тщательный контроль над настройками компилятора и иногда ручная проверка сгенерированного машинного кода.
\end{enumerate}

\section{Практические методы устранения уязвимостей для атак по времени исполнения}
Реализация средств защиты от атак по времени представляет собой многогранную задачу, включающую в себя баланс между безопасностью, производительностью и сложностью системы. Для решения этой задачи требуется глубокое понимание как аппаратного обеспечения, так и программного стека. Ранее были рассмотрены програмные методы устранения уязвимости, к примерам таких реализаций можно отнести OpenSSL и OpenSSL Constant-Time Implementations, Compiler-Based Mitigations в LLVM\cite{s10}. К примерам аппаратных решений можно отнести Intel Cache Allocation Technology (CAT)\cite{s8}, ARM TrustZone\cite{s9}. \par
Безопасность данных является важным направлением, которое постоянно развивается. Новые тенденции для защиты от атак по времени: применение машинного обучения для анализа по времени, гомоморфное шифрование, програмно-аппаратный дизайн, формальная верификация.

\section{Заключение}

Атаки через побочные каналы свидетельствуют о том, что даже если криптографический алгоритм математически силён, на практике он может оказаться небезопасен в зависимости от способа реализации и дизайна системы в целом. Проектирование безопасной системы должно охватывать все её аспекты, включая криптографические и некриптографические. Криптографические алгоритмы, основанные на модульном экспоненте, такие как RSA, могут быть уязвимы для атак по времени. Если операция экспоненцирования, в которой участвует секретный ключ, может быть засечена злоумышленником с достаточной точностью, ключ может быть восстановлен с помощью тщательно отобранных входных значений, количество которых пропорционально длине ключа. Существуют практические реализации атаки, поэтому она представляет настоящую важность. Защита от таких атак возможна и это является необходимостью для безопасности шифровальных систем.

%\hfil \hbox to 0.3\textwidth{\hrulefill} \smallskip

%Благодарности
%Работа выполнена при поддержке Минобрнауки, проект № 10А.100.

%Литература
\begin{thebibliography}{99}

\bibitem{s1}  \textit{P.Kocher, https://paulkocher.com/doc/TimingAttacks.pdf} Timing attacks on implementations of Diffie-Hellman, RSA, DSS, and other systems
\bibitem{s2}  \textit{J.F. Dhem, F. Koeune, P.-A. Leroux, J.-L. Willems, https://www.researchgate.net/publication/220962876} A practical implementation of the timing attack
\bibitem{s3}  \textit{D.Brumley and D. Boneh, https://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf} Remote Timing Attacks are Practical
\bibitem{s4}  \textit{European Information Technologies Certification Academy} What is a timing attack?
\bibitem{s5}  \textit{European Information Technologies Certification Academy} What role does the branch predictor play in CPU timing attacks, and how can attackers manipulate it to leak sensitive information?
\bibitem{s6}  \textit{European Information Technologies Certification Academy} What are some of the challenges and trade-offs involved in implementing hardware and software mitigations against timing attacks while maintaining system performance?
\bibitem{s7}  \textit{European Information Technologies Certification Academy} How can constant-time programming help mitigate the risk of timing attacks in cryptographic algorithms?
\bibitem{s20}  \textit{Wing H. Wong, https://www.cs.sjsu.edu/faculty/stamp/students/article.html} Timing Attacks on RSA: Revealing Your Secrets through the Fourth Dimension
\bibitem{s8}  \textit{Intel technical articles} Introduction to Cache Allocation Technology
\bibitem{s9}  \textit{Arm technologies} Arm TrustZone
\bibitem{s10}  \textit{llvm devmtg slides} Does LLVM implement security hardenings correctly?
\bibitem{s11}  \textit{Yuval Yarom, Daniel Genkin, and Nadia Heninger} CacheBleed: A Timing Attack on OpenSSL Constant Time RSA
\bibitem{s12}  \textit{National Institute of Standards and Technology} FIPS 197, Advanced Encryption Standard (AES)
\bibitem{s13}  \textit{Daniel J. Bernstein, The University of Illinois at Chicago} Cache-timing attacks on AES
\bibitem{s14}  \textit{European Information Technologies Certification Academy} CacheBleed: A Timing Attack on OpenSSL Constant Time RSA

%\bibitem{s1} \textit{Шевченко Д.\,В., Шевченко В.\,П.} Выбор и оптимизация структуры построения автономных сейсмических средств обнаружения рубежного типа // Материалы VIII всероссийской научно-технической конференции <<Современные охранные технологии и средства обеспечения комплексной безопасности объектов>>. --- 2010. --- С.~128--133.

%\bibitem{s2} \textit{Diallo M.\,S., Kulesh M., Holschneider M., Sherbaum F., Adler F.} Characterization of polarization attributes of seismic waves using continuous wavelet transforms // Geophysics.~--- 2006.~--- V.~71, N.~3.~--- P.~67--77.

%\bibitem{s3}  \textit{Лайонс Р.}  Цифровая обработка сигналов.~--- М.: Бином, 2006.~--- С.~361--369.

\end{thebibliography}

%References
%\selectlanguage{english}
%\begin{thebibliography}{99}
%\selectlanguage{russian}

%\bibitem{s1} \textit{Shevchenko D.\,V., Shevchenko V.\,P.} Selection and optimization of constructing autonomous seismic detection struction a landmark type // Proceedings of the VIII Russian scientific conference ‘‘Modern security technology and means of complex security objectives’’.~--- 2010. --- P.~128--133. --- (in Russian).

%\bibitem{s2} \textit{Diallo M.\,S., Kulesh M., Holschneider M., Sherbaum F., Adler F.} Characterization of polarization attributes of seismic waves using continuous wavelet transforms // Geophysics.~--- 2006.~--- V.~71, N.~3.~--- P.~67--77.

%\bibitem{s3}  \textit{Lyons R.} Digital signal processing.~--- M.: Binom, 2006.~--- P.~361--369. --- (in Russian).

%\end{thebibliography}
%\selectlanguage{russian}

%\begin{flushright}
% \textit{Поступила в редакцию дд.мм.гггг.}
%\end{flushright} 
